import os
import subprocess
from typing import Optional, Tuple

class ShellBuiltins:
    """
    Simulates built-in commands. Handlers now return a tuple:
    (status_code: int, output_text: Optional[str], should_exit: bool)

    status_code: 0 - executed successfully 
    status_code: 1 - executed unsuccessfully
    """

    def __init__(self):
        """
        Auto-register every builtin command.

        Rule (non-negotiable):
        A method is a builtin **iff** its name starts with ``cmd_``.
        The exposed command name is the part after the prefix.

        Examples
        --------
        cmd_echo  →  users type ``echo``
        cmd_ls    →  users type ``ls``

        Adding a new builtin is a single step:
        1. Add a method called cmd_<command_name> to this class.
        2. Nothing else.

        The one-liner below builds the lookup table once, at start-up,
        so the runtime cost is zero and the human cost is minimal.

        
        COMMAND HANDLER CONTRACT:
        All command handler methods (cmd_*) MUST return a CommandResult tuple:
        (STATUS_CODE: int, OUTPUT_TEXT: Optional[str], SHOULD_EXIT: bool)

        1. STATUS_CODE: The exit status of the command (0 for success, non-zero for failure).
        2. OUTPUT_TEXT: The output (stdout/stderr) generated by the command, or None.
        3. SHOULD_EXIT: True if the shell should terminate immediately (only for 'exit').
        """
        self.builtin_commands = {
            name[4:]: getattr(self, name)
            for name in dir(self) if name.startswith('cmd_')
        }

        # Store the not-found handler as a separate, easily accessible attribute
        self.not_found_handler = self.cmd_not_found

        # --- DEFINED CONSTANTS FOR RETURN VALUES ---
        self.STATUS_CODE_SUCCESS: int = 0
        self.STATUS_CODE_FAILED: int = 1
        self.SHOULD_EXIT: bool = True
        self.SHOULD_NOT_EXIT: bool = False
        self.COMMAND_NOT_FOUND_EXIT_FLAG: int = 127
        # -------------------------------------------

        # --- DEFINED SUBPROCESS COMMANDS FOR WINDOWS ---
        self.SUBPROCESS_WINDOWS_CLEAR = "cls"
        # -------------------------------------------

        # --- DEFINED SUBPROCESS COMMANDS FOR LINUX ---
        self.SUBPROCESS_LINUX_CLEAR = "clear"
        # -------------------------------------------

    def _find_executable_in_path(self, executable_file_name: str) -> Optional[str]:
        """
        Searches directories listed in the PATH environment variable for an executable file.
        """
        # Get PATH environment variable and split it by ':'
        path_dirs = os.environ.get("PATH", "").split(os.pathsep) 
        
        for folder_path in path_dirs:
            potential_path = os.path.join(folder_path, executable_file_name)
            
            # Check if the path exists, is a file, and is executable
            if os.path.isfile(potential_path) and os.access(potential_path, os.X_OK):
                return potential_path
        
        return None


    def cmd_exit(self, *_) -> Tuple[int, Optional[str], bool]:
        """Exits the program"""
        print("Exiting shell.")
        return (self.STATUS_CODE_SUCCESS, None, self.SHOULD_EXIT)


    def cmd_echo(self, _cmd: str, args: list[str]) -> Tuple[int, Optional[str], bool]:
        """Echo back user arguments."""
        output = " ".join(args)
        return (self.STATUS_CODE_SUCCESS, output, self.SHOULD_NOT_EXIT)


    def cmd_type(self, _cmd: str, _args: list[str]) -> Tuple[int, Optional[str], bool]:
        """Show if a command is builtin."""

        # TO IMPLEMENT
        pass


    def cmd_pwd(self, _cmd: str, _args: list[str]) -> Tuple[int, Optional[str], bool]:
        """Displays current working directory."""
        output = os.getcwd()
        return (self.STATUS_CODE_SUCCESS, output, self.SHOULD_NOT_EXIT)


    def cmd_cd(self, _cmd: str, args: list[str]) -> Tuple[int, Optional[str], bool]:
        """Changes the current working directory"""

        # USER HOME DIRECTORY 
        # os.path.expanduser() checks if the given path starts with a tilde (~). 
        # If it does, it replaces the ~ with the path to the current user's home directory.
        # It saves typing the full, often long and complex path (like /Users/jdoe/ or /home/serveradmin/) every time you want to reference something relative to your personal workspace.

        # ABSOLUTE PATH
        # A bsolute Path: A path that contains the complete location of a file or directory, starting from the file system's root directory.
        # Examples: /home/user/file (Starts with /) or C:\Users\user\file (Starts with a drive letter).

        # cd requires exactly zero or one argument.
        if len(args) > 1:
            return self.STATUS_CODE_SUCCESS, "cd: too many arguments", self.SHOULD_NOT_EXIT
        
        raw_path = args[0] if args else ""
        target_path = ""
        final_path = ""

        # Handle Empty Path (Default to Home)
        if not raw_path:
            raw_path = "~"

        # Handle Tilde Expansion 
        if raw_path.startswith("~"):
            target_path = os.path.expanduser(raw_path)

        # Handle absolute paths
        elif os.path.isabs(raw_path):
            target_path = raw_path

        # Handle relative paths
        else:
            target_path = os.path.join(os.getcwd(), raw_path)

        # Normalization (Cleanup)
        final_path = os.path.normpath(target_path) 
        
        # --- Execution and Error Handling ---
        try:
            os.chdir(final_path)

            # Success: Return status 0 (Success) and no output text.
            return (self.STATUS_CODE_SUCCESS, None, self.SHOULD_NOT_EXIT)
        
        except OSError as e:
            # Failure: Catch any OS-level error (non-existent folder, permission issues, etc.)
            error_message = f"cd: {raw_path}: {e.strerror}"

            # Return status 1 (Failed) and the error message.
            return (self.STATUS_CODE_FAILED, error_message, self.SHOULD_NOT_EXIT)


    def cmd_cat(self, cmd: str, args: list[str]) -> Tuple[int, Optional[str], bool]:
        """
        
        """
        # TO IMPLEMENT
        pass


    def cmd_clear(self, _cmd: str, _args: list[str]) -> Tuple[int, Optional[str], bool]:
        """
        Handles cleaning user terminal from all commands and outputs
        """

        os.system(self.SUBPROCESS_WINDOWS_CLEAR if os.name == "nt" else "clear")
        return (self.STATUS_CODE_SUCCESS, None, self.SHOULD_NOT_EXIT)
    

    def cmd_mkdir(self, _cmd: str, args: list[str]) -> Tuple[int, Optional[str], bool]:
        """
        Creates new directory
        """

        folder_name = args[0]
        os.mkdir(folder_name)

        return (self.STATUS_CODE_SUCCESS, None, self.SHOULD_NOT_EXIT)


    def cmd_rmdir(self, cmd, args) -> Tuple[int, Optional[str], bool]:
        """
        Removes directory
        """

        try:
            folder_name = args[0]
            os.rmdir(folder_name)

            return (self.STATUS_CODE_SUCCESS, None, self.SHOULD_NOT_EXIT)

        except Exception as e:
            error_output = f"shell: execution error for {cmd}: {e}"
            return (self.STATUS_CODE_FAILED, error_output, self.SHOULD_NOT_EXIT)
        

    def cmd_touch(self, cmd: str, args: list[str]) -> Tuple[int, Optional[str], bool]:
        """
        Creates a file
        """
        try:
            open(args[0], "w").close()
            return (self.STATUS_CODE_SUCCESS, None, self.SHOULD_NOT_EXIT)

        except Exception as e:
            error_output = f"shell: execution error for {cmd}: {e}"
            return (self.STATUS_CODE_FAILED, error_output, self.SHOULD_NOT_EXIT)
        

    def cmd_rm(self, cmd: str, args: list[str]) -> Tuple[int, Optional[str], bool]:
        """
        Deletes a file
        """

        try:
            os.remove(args[0])
            return (self.STATUS_CODE_SUCCESS, None, self.SHOULD_NOT_EXIT)

        except Exception as e:
            error_output = f"shell: execution error for {cmd}: {e}"
            return (self.STATUS_CODE_FAILED, error_output, self.SHOULD_NOT_EXIT)


    def cmd_not_found(self, cmd_name: str, args: list[str]) -> Tuple[int, Optional[str], bool]:
        """
        Handler for unknown commands. Attempts to find and execute the command as
        an external program via subprocess.
        """

        executable_path = self._find_executable_in_path(cmd_name)

        if executable_path is None:
            # Command not found, return status 127
            error_output = f"{cmd_name}: command not found"
            return (self.COMMAND_NOT_FOUND_EXIT_FLAG, error_output, self.SHOULD_NOT_EXIT)
        
        # Command found, execute it
        try:
            # subprocess.run executes the command.
            # capture_output=True captures stdout and stderr.
            # text=True decodes stdout/stderr as text.

            result = subprocess.run(
                [executable_path, *args], 
                capture_output=True, 
                text=True,
                check=False # Do not raise CalledProcessError for non-zero exit codes
            )

            # Combine stdout and stderr for the output buffer
            output = (result.stdout + result.stderr).strip()

            # Return the external command's return code and use constant for exit flag
            return (result.returncode, output, self.SHOULD_NOT_EXIT)
        
        except Exception as e:
            # Catch execution errors (e.g., permission denied)
            error_output = f"shell: execution error for {cmd_name}: {e}"
            # Use constant for failure code and exit flag
            return (self.STATUS_CODE_FAILED, error_output, self.SHOULD_NOT_EXIT)